"use strict";(self.webpackChunklightning_docs=self.webpackChunklightning_docs||[]).push([[2464],{3905:(e,n,t)=>{t.d(n,{Zo:()=>g,kt:()=>d});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),s=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},g=function(e){var n=s(e.components);return o.createElement(l.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,g=r(e,["components","mdxType","originalType","parentName"]),c=s(t),u=a,d=c["".concat(l,".").concat(u)]||c[u]||m[u]||i;return t?o.createElement(d,p(p({ref:n},g),{},{components:t})):o.createElement(d,p({ref:n},g))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,p=new Array(i);p[0]=u;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r[c]="string"==typeof e?e:a,p[1]=r;for(var s=2;s<i;s++)p[s]=t[s];return o.createElement.apply(null,p)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},5124:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>p,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>s});var o=t(7462),a=(t(7294),t(3905));const i={},p="Component Type Configs",r={unversionedId:"TypeScript/Components/TypeConfigs",id:"TypeScript/Components/TypeConfigs",title:"Component Type Configs",description:"Type Configs define other types, outside of the Template Specs, that are used by a Component.",source:"@site/docs/TypeScript/Components/TypeConfigs.md",sourceDirName:"TypeScript/Components",slug:"/TypeScript/Components/TypeConfigs",permalink:"/lightning-docs/docs/TypeScript/Components/TypeConfigs",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/TypeScript/Components/TypeConfigs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Component Template Specs",permalink:"/lightning-docs/docs/TypeScript/Components/TemplateSpecs"},next:{title:"Guidelines / Gotchas",permalink:"/lightning-docs/docs/TypeScript/GuidelinesGotchas"}},l={},s=[{value:"Basic Structure",id:"basic-structure",level:2},{value:"Defining a Type Config",id:"defining-a-type-config",level:2},{value:"Event Maps",id:"event-maps",level:2},{value:"Signal Maps",id:"signal-maps",level:2},{value:"Loose Type Configs",id:"loose-type-configs",level:2}],g={toc:s},c="wrapper";function m(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,o.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"component-type-configs"},"Component Type Configs"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Type Configs")," define other types, outside of the ",(0,a.kt)("a",{parentName:"p",href:"/lightning-docs/docs/TypeScript/Components/TemplateSpecs"},"Template Specs"),", that are used by a Component."),(0,a.kt)("p",null,"A Type Config is provided, optionally, as the 2nd generic parameter of the ",(0,a.kt)("inlineCode",{parentName:"p"},"Lightning.Component")," base class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent\n  extends Lightning.Component<MyComponentTemplateSpec, MyComponentTypeConfig> /* ... */ {\n    // ...\n  }\n")),(0,a.kt)("h2",{id:"basic-structure"},"Basic Structure"),(0,a.kt)("p",null,"Below is a reproduction of the base ",(0,a.kt)("inlineCode",{parentName:"p"},"TypeConfig")," interface that you extend to provide your own Type Config for a Component."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface TypeConfig {\n  EventMapType: Lightning.Component.EventMap;\n  SignalMapType: Lightning.Component.SignalMap;\n  TextureType: Lightning.Texture;\n\n  // If you are using Lightning SDK the following options are available:\n  IsPage: boolean;\n  HistoryStateType: Record<string, unknown>\n}\n")),(0,a.kt)("p",null,"Definitions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"EventMapType"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The EventMap to associate with a Component"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"SignalMapType"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The SignalMap to associate with a Component"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TextureType"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The Texture class to make available in a Component's ",(0,a.kt)("inlineCode",{parentName:"li"},"texture")," property."))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"IsPage")," (Lightning SDK only)",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"If set to ",(0,a.kt)("inlineCode",{parentName:"li"},"true")," designates the Component as a Router Page"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"HistoryStateType")," (Lightning SDK only)",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The type to use for Router History State."),(0,a.kt)("li",{parentName:"ul"},"Used only if ",(0,a.kt)("inlineCode",{parentName:"li"},"IsPage")," is set to ",(0,a.kt)("inlineCode",{parentName:"li"},"true"),".")))),(0,a.kt)("h2",{id:"defining-a-type-config"},"Defining a Type Config"),(0,a.kt)("p",null,"Define a Type Config for a Component by first creating an interface that extends ",(0,a.kt)("inlineCode",{parentName:"p"},"Lightning.Component.TypeConfig"),". You only need to add the keys that you'd like to override for your Component."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface MyComponentTypeConfig extends Lightning.Component.TypeConfig {\n  EventMapType: MyComponentEventMap;\n  SignalMapType: MyComponentSignalMap;\n}\n")),(0,a.kt)("p",null,"Below describes how to define each of the types."),(0,a.kt)("h2",{id:"event-maps"},"Event Maps"),(0,a.kt)("p",null,"Event Maps define the specific events and the parameter structure of those events that a Component emits."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface MyComponentEventMap extends Lightning.Component.EventMap {\n  titleLoaded(): void;\n  ratingColor(color: number, visible: boolean): void;\n}\n")),(0,a.kt)("p",null,"When this Event Map is set on a Component, the various EventEmitter calls on a Component instance will utilize them for type-checking and IDE hints."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"this.emit('titleLoaded');\nthis.emit('ratingColor', 123, true);\n\nthis.on('titleLoaded', () => {});\nthis.on('ratingColor', (color, visible) => { console.log(color, visible); })\n\nthis.removeAllListeners('titleLoaded');\nthis.removeAllListeners('ratingColor');\n")),(0,a.kt)("h2",{id:"signal-maps"},"Signal Maps"),(0,a.kt)("p",null,"Signal Maps define the specific ",(0,a.kt)("a",{parentName:"p",href:"/lightning-docs/docs/Communication/Signal"},"Signals")," and parameter structure that a Component emits."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface MyComponentSignalMap extends Lightning.Component.SignalMap {\n  signalName(): void;\n  toggleText(alpha: number, color: string): void;\n  toggleImage(alpha: number): void;\n}\n")),(0,a.kt)("p",null,"When this Signal Map is set on a Component, the various signal interaction points on a Component instance will utilize them for type-checking and IDE hints:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent\n  extends Lightning.Component<MyComponentSpec, MyComponentTypeConfig> /* ... */ {\n\n  override _handleEnter() {\n    this.signal('signalName');\n    this.signal('toggleText', 1.0, 'red');\n    this.signal('toggleImage', 0.5);\n  }\n}\n\nclass MyParentComponent extends Lightning.Component {\n  static _template() {\n    return {\n      Button: {\n        type: MyComponent,\n        signals: {\n          // These keys / values are type checked\n          signalName: true,\n          toggleText: '_toggleText',\n          toggleImage(alpha) { /* ... */ }\n        },\n        passSignals: {\n          // Same for Pass Signals\n          signalName: true,\n          toggleText: 'renamedSignal',\n        }\n      }\n    }\n\n    // Warning: Signal handler signatures are NOT type checked\n    _toggleText(alpha: number, color: string) {\n      // ...\n    }\n  }\n  // ...\n}\n")),(0,a.kt)("h2",{id:"loose-type-configs"},"Loose Type Configs"),(0,a.kt)("p",null,"If a Type Config is not explicitly provided, a ",(0,a.kt)("strong",{parentName:"p"},"Loose Type Config")," will be used by default. This is similar to the ",(0,a.kt)("a",{parentName:"p",href:"/lightning-docs/docs/TypeScript/Components/TemplateSpecs"},(0,a.kt)("strong",{parentName:"a"},"Loose Template Spec")),". Events and Signals will be handled in a much more looser fashion, allowing you to hook up any Events/Signals regardless of if any are explicitly specified."),(0,a.kt)("p",null,"You can also explicitly extend the base ",(0,a.kt)("inlineCode",{parentName:"p"},"LooseTypeConfig")," interface if you want the best of both worlds. Explicitly specified Events and Signals will be type checked. But any other Event or Signal will be allowed and be able to emit/receive ",(0,a.kt)("inlineCode",{parentName:"p"},"any")," set of parameters."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export interface TypeConfigLoose extends Lightning.Component.TypeConfigLoose {\n  SignalMapType: MyComponentSignalMap,\n  EventMapType: MyComponentEventMap\n}\n")))}m.isMDXComponent=!0}}]);