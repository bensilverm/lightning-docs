"use strict";(self.webpackChunklightning_docs=self.webpackChunklightning_docs||[]).push([[7099],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?p(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},p=Object.keys(e);for(a=0;a<p.length;a++)n=p[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(a=0;a<p.length;a++)n=p[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,p=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=l(n),h=o,u=c["".concat(s,".").concat(h)]||c[h]||d[h]||p;return n?a.createElement(u,r(r({ref:t},m),{},{components:n})):a.createElement(u,r({ref:t},m))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var p=n.length,r=new Array(p);r[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:o,r[1]=i;for(var l=2;l<p;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9928:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>p,metadata:()=>i,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const p={},r="Subclassable Components",i={unversionedId:"TypeScript/Components/SubclassableComponents",id:"TypeScript/Components/SubclassableComponents",title:"Subclassable Components",description:"Usually, when creating a Lightning Component you do not need to specify your own generic parameters which are mixed into the ones passed further down into the Component base class. However, there are times when you want to make your Component type flexible and perhaps just as flexible as the Component base class which allows you to pass a Template Spec and Type Config. Perhaps you want to create a PageBase component that accepts any child Component of type T. Or a completely flexible MyBaseComponent which all of your App's Components extend. When doing this there are a few guidelines and gotchas you need to pay attention to that stem from some design choices in TypeScript.",source:"@site/docs/TypeScript/Components/SubclassableComponents.md",sourceDirName:"TypeScript/Components",slug:"/TypeScript/Components/SubclassableComponents",permalink:"/lightning-docs/docs/TypeScript/Components/SubclassableComponents",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/TypeScript/Components/SubclassableComponents.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Components",permalink:"/lightning-docs/docs/TypeScript/Components/"},next:{title:"Component Template Specs",permalink:"/lightning-docs/docs/TypeScript/Components/TemplateSpecs"}},s={},l=[{value:"Basic Generic Ref Type",id:"basic-generic-ref-type",level:2},{value:"Extendible TemplateSpec / TypeConfig",id:"extendible-templatespec--typeconfig",level:2}],m={toc:l},c="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"subclassable-components"},"Subclassable Components"),(0,o.kt)("p",null,"Usually, when creating a Lightning Component you do not need to specify your own generic parameters which are mixed into the ones passed further down into the Component base class. However, there are times when you want to make your Component type flexible and perhaps just as flexible as the Component base class which allows you to pass a ",(0,o.kt)("a",{parentName:"p",href:"/lightning-docs/docs/TypeScript/Components/TemplateSpecs"},"Template Spec")," and ",(0,o.kt)("a",{parentName:"p",href:"./TypeConfig.md"},"Type Config"),". Perhaps you want to create a ",(0,o.kt)("inlineCode",{parentName:"p"},"PageBase<T>")," component that accepts any child Component of type T. Or a completely flexible ",(0,o.kt)("inlineCode",{parentName:"p"},"MyBaseComponent<TemplateSpecType, TypeConfig>")," which all of your App's Components extend. When doing this there are a few guidelines and gotchas you need to pay attention to that stem from some design choices in TypeScript."),(0,o.kt)("h2",{id:"basic-generic-ref-type"},"Basic Generic Ref Type"),(0,o.kt)("p",null,"If we want to create an extendible base Component called ",(0,o.kt)("inlineCode",{parentName:"p"},"PageBase<T>"),", where ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," is the type of Component used for the content of a page appearing with a static header component, we start by laying down the definition of its Template Spec like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface PageTemplateSpec<\n  T extends Lightning.Component.Constructor = Lightning.Component.Constructor,\n> extends Lightning.Component.TemplateSpec {\n  Header: typeof Header\n  Content: T\n}\n")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Lightning.Component.Constructor")," represents a ",(0,o.kt)("inlineCode",{parentName:"p"},"typeof")," any Lightning Component. For example, if there's a component called ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," you can use ",(0,o.kt)("inlineCode",{parentName:"p"},"typeof List")," as the type argument for ",(0,o.kt)("inlineCode",{parentName:"p"},"T"),"."),(0,o.kt)("p",null,"Then we implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"PageBase")," class itself using the same generic type parameter passed down into the Template Spec:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export class PageBase<T extends Lightning.Component.Constructor = Lightning.Component.Constructor>\n  extends Lightning.Component<PageTemplateSpec<T>>\n  implements Lightning.Component.ImplementTemplateSpec<PageTemplateSpec<T>>\n{\n  static override _template(): Lightning.Component.Template<PageTemplateSpec> {\n    return {\n      w: (w: number) => w,\n      h: (h: number) => h,\n      rect: true,\n      color: 0xff0e0e0e,\n\n      Header: {\n        type: Header,\n      },\n      Content: undefined,\n    };\n  }\n\n  Content = this.getByRef('Content')!;\n}\n")),(0,o.kt)("p",null,"We fill the base ",(0,o.kt)("inlineCode",{parentName:"p"},"_template()")," out with how we want our base component to appear. Here a Header component is provided and we leave the Content component intentionally ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),". It will be provided by the subclass implementation. We also create a read-only property for ",(0,o.kt)("inlineCode",{parentName:"p"},"Content")," which returns the result of ",(0,o.kt)("inlineCode",{parentName:"p"},"getByRef('Content')"),"."),(0,o.kt)("p",null,"Notice how the return type of ",(0,o.kt)("inlineCode",{parentName:"p"},"_template()")," does not reference ",(0,o.kt)("inlineCode",{parentName:"p"},"T"),". Due to how class generics work in TypeScript you are not allowed to pass the generic parameters from the class definition. By leaving it out we open it to be used for any Lightning Component type."),(0,o.kt)("p",null,"With this base we are ready to implement a subclass. Here we use a component called ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," as our Content component:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export class Discovery extends BasePage<typeof List> {\n  static override _template(): Lightning.Component.Template<IPageTemplateSpec<typeof List>> {\n    // Must assert the specific template type to the type of the template spec\n    // because `super._template()` isn't/can't be aware of List\n    const pageTemplate = super._template() as Lightning.Component.Template<\n      IPageTemplateSpec<typeof List>\n    >;\n\n    pageTemplate.Content = {\n      type: List,\n      w: (w: number) => w,\n      h: (h: number) => h,\n    };\n\n    return pageTemplate;\n  }\n\n  override _init() {\n    this.Content.someListSpecificProperty = false;\n  }\n}\n")),(0,o.kt)("p",null,"Here the ",(0,o.kt)("inlineCode",{parentName:"p"},"_template()")," method calls the base component's ",(0,o.kt)("inlineCode",{parentName:"p"},"_template()")," method, and then supplements it's Content ref with the ",(0,o.kt)("inlineCode",{parentName:"p"},"List")," component. We must use ",(0,o.kt)("inlineCode",{parentName:"p"},"as")," to assert the correct final type of the template object because of what we said above about class generic parameters and static methods. From here, you should be able to reference ",(0,o.kt)("inlineCode",{parentName:"p"},"this.Content")," in your component's implementation and it will automatically be resolved to an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"List"),"."),(0,o.kt)("h2",{id:"extendible-templatespec--typeconfig"},"Extendible TemplateSpec / TypeConfig"),(0,o.kt)("p",null,"If we wish to create our own ",(0,o.kt)("inlineCode",{parentName:"p"},"MyBaseComponent")," that provides its own base Template Spec and Event Map. First we start by creating our own interfaces for Template Spec and Type Config that extend their respective base interfaces from Component. The wrapping namespace ",(0,o.kt)("inlineCode",{parentName:"p"},"MyBaseComponent")," is used purely for convention and organization. It is recommended but not required."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"declare namespace MyBaseComponent {\n  export interface TemplateSpec extends lng.Component.TemplateSpecStrong {\n    MyBaseElement: {}\n  }\n\n  export interface EventMap extends lng.Component.EventMap {\n    myBaseEvent(): void;\n  }\n\n  export interface TypeConfig extends lng.Component.TypeConfig {\n    EventMapType: EventMap\n  }\n}\n")),(0,o.kt)("p",null,"Note we added our own event ",(0,o.kt)("inlineCode",{parentName:"p"},"myBaseEvent")," as well as an element called ",(0,o.kt)("inlineCode",{parentName:"p"},"MyBaseElement"),"."),(0,o.kt)("p",null,"Now we create the class. Supply two generic type parameters: ",(0,o.kt)("inlineCode",{parentName:"p"},"TemplateSpec")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"TypeConfig")," in that order. Both should be constrained to extend from their respective interfaces that we just wrote above. Those same interfaces, respectively, should be assigned as the defaults for the parameters. This allows the type ",(0,o.kt)("inlineCode",{parentName:"p"},"MyBaseComponent")," to be referenced without generic parameters which is useful to potential users and our implementation."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyBaseComponent<\n  TemplateSpec extends MyBaseComponent.TemplateSpec = MyBaseComponent.TemplateSpec,\n  TypeConfig extends MyBaseComponent.TypeConfig = MyBaseComponent.TypeConfig\n> extends lng.Component<TemplateSpecType, TypeConfig> {\n\n}\n")),(0,o.kt)("p",null,"All of this so far is logical. We want to extend the interface types from Component, so we extend them and essentially rebuild the generic parameter list from the base ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," class but using our new interfaces in place of the original ones from Component. We're now effectively allowing fully extensible subclasses from our base component."),(0,o.kt)("p",null,"Things get a bit tricky in our own implementation of the base component. Because the types for ",(0,o.kt)("inlineCode",{parentName:"p"},"TemplateSpec")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"TypeConfig")," are not known at the implementation level, base methods from ",(0,o.kt)("inlineCode",{parentName:"p"},"Component")," that rely on these types do not work normally. You would expect a statement like ",(0,o.kt)("inlineCode",{parentName:"p"},"this.getByRef('MyBaseElement')")," to just work. After all, we just told TypeScript that the ",(0,o.kt)("inlineCode",{parentName:"p"},"TemplateSpec")," generic param has to extend MyBaseComponent's Template Spec which includes MyBaseElement. But due to how ",(0,o.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/73030517/1908298"},"TypeScript handles generics and generic constraints")," this information is not enough for it to make confident decisions about what the type of ",(0,o.kt)("inlineCode",{parentName:"p"},"TemplateSpec")," is when it is finally subclassed. So each of the generic type parameters are treated like a black box, and that getByRef call and even ",(0,o.kt)("inlineCode",{parentName:"p"},"this.emit('myBaseEvent')")," will cause a TypeScript error. The error is ugly and can vary so we won't repeat it here."),(0,o.kt)("p",null,"Thankfully TypeScript offers us a solution that, while a bit of a pain, is easy to employ. And, again, this should not be needed for 95%+ of the Components you write. You can tell TypeScript to assert the ",(0,o.kt)("inlineCode",{parentName:"p"},"this")," keyword is a fully known ",(0,o.kt)("inlineCode",{parentName:"p"},"MyBaseComponent"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyBaseComponent /* ... */ {\n  MyBaseElement: lng.Element = (this as MyBaseComponent).getByRef('MyBaseElement')!;\n\n  override _init() {\n    (this as MyBaseComponent).emit('myBaseEvent');\n  }\n}\n")),(0,o.kt)("p",null,"Remember when we provided defaults for each of the generic type params? That allows these assertions to be written in this much cleaner abbreviated way while also remaining intuitive."),(0,o.kt)("p",null,"There are other ways to do this, if you don't want to wrap the as type assertion in every statement where it is needed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyBaseComponent /* ... */ {\n  MyBaseElement: lng.Element = (this as MyBaseComponent).getByRef('MyBaseElement')!;\n\n  // Upcast `this` for entire method\n  // https://www.typescriptlang.org/docs/handbook/2/classes.html#this-parameters\n  override _handleEnter(this: MyBaseComponent) {\n    this.emit('myBaseEvent');\n  }\n\n  override _init() {\n    // Upcasting type of `this` in a constant\n    const thiz: MyBaseComponent = this;\n    thiz.emit('myBaseEvent');\n  }\n}\n")))}d.isMDXComponent=!0}}]);