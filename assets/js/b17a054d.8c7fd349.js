"use strict";(self.webpackChunklightning_docs=self.webpackChunklightning_docs||[]).push([[6805],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>u});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),c=s(n),d=o,u=c["".concat(l,".").concat(d)]||c[d]||h[d]||i;return n?a.createElement(u,r(r({ref:t},m),{},{components:n})):a.createElement(u,r({ref:t},m))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=d;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[c]="string"==typeof e?e:o,r[1]=p;for(var s=2;s<i;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7034:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var a=n(7462),o=(n(7294),n(3905));const i={},r="Component Template Specs",p={unversionedId:"TypeScript/Components/TemplateSpecs",id:"TypeScript/Components/TemplateSpecs",title:"Component Template Specs",description:"Much of the time when writting a Lightning application, you're writting Components. Within each Component you define a Template which defines the starting properties, structure of children and properties of the children. For TypeScript to be aware of the structure of a Component's Template, you need to define what we call a Template Spec.",source:"@site/docs/TypeScript/Components/TemplateSpecs.md",sourceDirName:"TypeScript/Components",slug:"/TypeScript/Components/TemplateSpecs",permalink:"/lightning-docs/docs/TypeScript/Components/TemplateSpecs",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/TypeScript/Components/TemplateSpecs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Subclassable Components",permalink:"/lightning-docs/docs/TypeScript/Components/SubclassableComponents"},next:{title:"Component Type Configs",permalink:"/lightning-docs/docs/TypeScript/Components/TypeConfigs"}},l={},s=[{value:"Defining a Template Spec",id:"defining-a-template-spec",level:2},{value:"Using a Template Spec",id:"using-a-template-spec",level:2},{value:"Loose Components",id:"loose-components",level:2}],m={toc:s},c="wrapper";function h(e){let{components:t,...n}=e;return(0,o.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"component-template-specs"},"Component Template Specs"),(0,o.kt)("p",null,"Much of the time when writting a Lightning application, you're writting ",(0,o.kt)("a",{parentName:"p",href:"/lightning-docs/docs/TypeScript/Components/"},"Components"),". Within each Component you define a ",(0,o.kt)("a",{parentName:"p",href:"../Templates/index.md"},"Template")," which defines the starting properties, structure of children and properties of the children. For TypeScript to be aware of the structure of a Component's Template, you need to define what we call a ",(0,o.kt)("strong",{parentName:"p"},"Template Spec"),"."),(0,o.kt)("h2",{id:"defining-a-template-spec"},"Defining a Template Spec"),(0,o.kt)("p",null,"Template Specs contain two sections of information that define your Component:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Properties",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The publicly settable/gettable properties of your Component."),(0,o.kt)("li",{parentName:"ul"},"These are represented by keys that begin with a ",(0,o.kt)("strong",{parentName:"li"},"lower-case letter"),"."))),(0,o.kt)("li",{parentName:"ul"},"Children",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The child Components/Elements of your Component."),(0,o.kt)("li",{parentName:"ul"},"These are represented by keys that begin with an ",(0,o.kt)("strong",{parentName:"li"},"upper-case letter"),'. This key is the "ref" of the child.')))),(0,o.kt)("p",null,"Here's an example of a Template Spec with many of the types of structure explained:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface MyComponentTemplateSpec extends Lightning.Component.TemplateSpec {\n  /*\n    Properties\n    ----------\n    - Each key must begin with a lower-case letter\n\n    - The value type defines the type of the property\n\n    - Properties should never be marked optional (with `?`) so that TS can enforce that they are implemented in your Component.\n   */\n\n  // Simple properties\n  myProperty1: number;\n  myProperty2: string;\n  myProperty3: boolean;\n\n  // Content patch property\n  // If your Component has a property that accepts a patch object that is sent to `patch()`\n  // you can use the `PatchTemplate<ComponentTemplateSpecType>` type.\n  myContentProperty: Lightning.Element.PatchTemplate<Element.TemplateSpecLoose>;\n\n  /*\n    Children\n    --------\n    - Each key must begin with an upper-case letter\n\n    - The value type defines what kind of child it is\n\n    - Children should never be marked optional (with `?`) because it is already implied that any child\n      defined in the Template Spec may not exist at any given point during the lifetime of the application.\n   */\n\n  // Child components are inserted with the Component class type preceeded by `typeof`\n  MyChildComponent: typeof MyChildComponent\n\n  // Child elements, which contain no children, are inserted with `object`\n  MyChildElementWithNoChildren: object\n\n  // Child elements, which have children of their own, are inserted with an inline-object type.\n  // The same rules that apply to Template Spec children apply to these nested Children.\n  MyChildElementWithChildren: {\n    GrandChild1: typeof MyCoolComponent;\n    GrandChild2: object;\n    GrandChild3: {\n      GreatGrandChild1: object\n    };\n  };\n}\n")),(0,o.kt)("h2",{id:"using-a-template-spec"},"Using a Template Spec"),(0,o.kt)("p",null,"After you create a Template Spec, you can now apply it to your Component. Whether you are creating a new Component from scratch or converting an existing Component to TypeScript the idea is the same:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Extend from ",(0,o.kt)("inlineCode",{parentName:"li"},"Lightning.Component")," like normal, adding the Template Spec to the first generic parameter of it:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"extends Lightning.Component<MyTemplateSpec>")))),(0,o.kt)("li",{parentName:"ul"},"Implement the ",(0,o.kt)("inlineCode",{parentName:"li"},"Lightning.Component.ImplementTemplateSpec")," interface, adding the Template Spec to the first generic parameter as well:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"implements Lightning.Component.ImplementTemplateSpec<MyTemplateSpec>")))),(0,o.kt)("li",{parentName:"ul"},"Write the static ",(0,o.kt)("inlineCode",{parentName:"li"},"_template")," method signature, including ",(0,o.kt)("inlineCode",{parentName:"li"},"Lightning.Component.Template")," as the return value, but also adding the Template Spec as the generic param:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"static _template(): Lightning.Component.Template<MyTemplateSpec> {}"))))),(0,o.kt)("p",null,"It should look like the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent\n  extends Lightning.Component<MyTemplateSpec>\n  implements Lightning.Component.ImplementTemplateSpec<MyTemplateSpec> {\n\n  static override _template(): Lightning.Component.Template<MyTemplateSpec> {}\n}\n")),(0,o.kt)("p",null,"At this point, TypeScript should be giving you errors about the class not implementing the interface properly and ",(0,o.kt)("inlineCode",{parentName:"p"},"_template")," not returning the right thing. So next we satisfy the interface by implementing the necessary getters/setters necessary:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent /* ... */ {\n  // The ImplementTemplateSpec inteface will enforce that these are implemented\n  get myProperty1(): number { /* Implement */ }\n  set myProperty1(v: number) { /* Implement */ }\n  get myProperty2(): string { /* Implement */ }\n  set myProperty2(v: string) { /* Implement */ }\n  get myProperty3(): boolean { /* Implement */ }\n  set myProperty3(v: boolean) { /* Implement */ }\n  get myContentProperty(): Lightning.Element.PatchTemplate<Element.TemplateSpecLoose> { /* Implement */ }\n  set myContentProperty(v: Lightning.Element.PatchTemplate<Element.TemplateSpecLoose>) { /* Implement */ }\n\n  static override _template(): Lightning.Component.Template<MyTemplateSpec> {}\n}\n")),(0,o.kt)("p",null,"Next we implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"_template")," method based on our child structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent /* ... */ {\n  // ...\n  static override _template(): Lightning.Component.Template<MyTemplateSpec> {\n    return {\n      // Fill in the Element properties of the Component\n      // Notice the IDE auto-complete and documentation you get while entering each one\n      rect: true,\n      color: 0xffff0000,\n\n      // Fill in whatever Children you want. You are not required to fill all of them out. That is\n      // an implementation decision. You may want to create a child at a later time in the execution.\n      MyChildComponent: {\n        // Typescript enforces and provides auto-complete + documentation on all properties of children too!\n        type: MyChildComponent,\n        x: 10,\n        y: 20,\n        myChildComponentProp1: true\n      },\n      MyChildElementWithNoChildren: {\n        x: 30,\n        y: 40,\n        text: {\n          text: 'Some text',\n          textColor: 0xffff0000\n        }\n      },\n      MyChildElementWithChildren: {\n        rect: true,\n        color: 0xff00ff00,\n        GrandChild3: {\n          x: 50,\n          y: 40,\n          GreatGrandChild1: {\n            src: 'myasset.png'\n          }\n        }\n      }\n    }\n  }\n}\n")),(0,o.kt)("p",null,"You may then choose to make any of your Component's descendants easily accessible via private/public properties. ",(0,o.kt)("inlineCode",{parentName:"p"},"this.tag()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"this.getByRef()")," can be used to get at your components. We chose ",(0,o.kt)("inlineCode",{parentName:"p"},"getByRef()")," in the example below as it is a bit more performant. In either case, your IDE provides you with an auto-complete prompt on the valid child paths / ref names based on your TemplateSpec so you can avoid typos."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent /* ... */ {\n  /*\n    If our child is created on initialization (in _template) and is never removed/re-added, we can do a\n    simple one-time `getByRef()` call. This line is executed automatically in the Component's constructor.\n\n    Notice the prescene of the non-null assertion operator, `!`, at the end of the call. The return value for `getByRef()` is by default nullable. We use this operator to assert to TypeScript that the Element we are\n    getting will definitely exist when this line executes. This saves us time/performance later from having to check all the time\n\n    Also we've made our properties private so they are only accessible within the Component. The `_` prefix is\n    not necessary and can depend on your team's coding style.\n   */\n  private _MyChildElementWithChildren = this.getByRef('MyChildElementWithChildren')!;\n\n  /*\n    To access a grand-child we can do so through it's parent that we just defined!\n   */\n  private _GrandChild3 = this._MyChildElementWithChildren.getByRef('GrandChild3')!;\n\n  /*\n    If we want to give public access to our great-grand child we can do that like this:\n   */\n  GreatGrandChild1 = this._GrandChild3.getByRef('GreatGrandChild1')!;\n\n  /*\n    If we have a descendant that may or may not exist at any given time, we must implement it as a getter\n\n    This way `getByRef()` is called each time the descendant is needed. And note, this time we do not use\n    the `!` non-null assertion operator since it's existance must be checked at runtime.\n   */\n  get GrandChild1() {\n    return this._MyChildElementWithChildren.getByRef('GrandChild1');\n  }\n\n  // ...\n}\n")),(0,o.kt)("p",null,"For reference, here's the the equivalent using ",(0,o.kt)("inlineCode",{parentName:"p"},"tag()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent /* ... */ {\n  private _MyChildElementWithChildren = this.tag('MyChildElementWithChildren')!;\n  private _GrandChild3 = this.tag('MyChildElementWithChildren.GrandChild3')!;\n  GreatGrandChild1 = this.tag('MyChildElementWithChildren.GrandChild3.GreatGrandChild1')!;\n  get GrandChild1() {\n    return this.tag('MyChildElementWithChildren.GrandChild1')!;\n  }\n  // ...\n}\n")),(0,o.kt)("p",null,"Notice that you do not need to explicitly add types to each property. TypeScript automatically derives the types of each property from the return value type of ",(0,o.kt)("inlineCode",{parentName:"p"},"getByRef()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"tag()"),"."),(0,o.kt)("p",null,"At this point your Component should be set for further implementation and use as children by other Components."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class MyComponent /* ... */ {\n  override _handleEnter() {\n    if (!this.GrandChild1) {\n      this._MyChildElementWithChildren.patch({\n        color: 0xff0000ff,\n        GrandChild1: {\n          text: 'Hello World!'\n        }\n      });\n    }\n    this._GrandChild3.src = 'myOtherAsset.png';\n  }\n}\n")),(0,o.kt)("h2",{id:"loose-components"},"Loose Components"),(0,o.kt)("p",null,"If you'd like to opt-out of some of the type safety aspects within a Component you can create a Loose Template Spec. To do this simply extend your Template Spec from ",(0,o.kt)("inlineCode",{parentName:"p"},"Lightning.Component.TemplateSpecLoose"),". A Component that uses a Loose Template Spec is known as a Loose Component."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export interface MyComponentTemplateSpec extends Lightning.Component.TemplateSpecLoose {\n  // ...\n}\n")),(0,o.kt)("p",null,"Doing this allows any arbitrary properties / child ref keys, in addition to the ones declared in the Template Spec, to be set on your component during ",(0,o.kt)("inlineCode",{parentName:"p"},"_template")," creation and patches."),(0,o.kt)("p",null,"By default, all Components that do not set their own Template Spec are Loose. This allows Components that you may import from a third-party library that doesn't yet support TypeScript to be used in your app with little upfront friction."))}h.isMDXComponent=!0}}]);